\select@language {brazil}
\select@language {brazil}
\contentsline {chapter}{\numberline {1}Introdu\c {c}\~{a}o}{2}
\contentsline {subparagraph}{ O sigilo sempre foi uma arma explorada pelos seres humanos para vencer certas batalhas, mesmo que na cotidiana miss\~{a}o de se comunicar. Foi a partir dessa necessidade que se criou o que chamamos de \textit {criptografia}, nome dado ao conjunto de t\'ecnicas usadas para se falar e escrever em c\'odigos. Seu objetivo \'{e} garantir que apenas as pessoas envolvidas na comunica\c {c}\~ao possam compreender a mensagem codificada (ou criptogtafada), garantindo que terceiros n\~ao saibam o que foi conversado. }{2}
\contentsline {subparagraph}{ Para compreender como funciona o processo de codifica\c {c}\~ao e decodifica\c {c}\~ao faz-se necess\'ario o uso de uma s\'erie de termos t\'ecnicos, para fins pedag\'ogicos iremos introduzir tais conceitos apresentando um dos primeiros algor\'itmos criptogr\'aficos que se tem conhecimento, a criptografia de C\'esar, al\'em de seus sucessores. Caso queira se aprofudar sobre criptografia recomendamos a leitura de ``Criptografia" , por Coutinho \cite {coutinho} }{2}
\contentsline {subparagraph}{ A chamada \textit {criptografia de C\'esar}, criada pelo imperador romano C\'esar Augusto, consistia em substituir cada letra da mensagem por outra que estivesse a tr\^es posi\c {c}\~oes a frente, como, por exemplo, a letra \textbf {A} era substitu\'ida pela letra \textbf {D}. }{2}
\contentsline {subparagraph}{ Uma forma muito natural de se generalizar o algoritmo de C\'esar \'e fazer a troca de cada letra da mensagem por outra em uma posi\c {c}\~ao qualquer fixada. A chamada \textit {criptografia de substitui\c {c}\~ao monoalfab\'etica} consite em substituir cada letra por outra que ocupe $n$ posi\c {c}\~oes a sua frente, sendo que o n\'umero $n$ \'e conhecido apenas pelo emissor e pelo receptor da mensagem. Chamamos este n\'umero $n$ de \textit {chave criptogr\'afica}. Para podermos compreender a mensagem, precisamos substituir as letras que formam a mensagem criptografada pelas as que est\~ao $n$ posi\c {c}\~oes antes. }{3}
\contentsline {subparagraph}{ O algoritmo monoalfab\'etico tem a caracter\'istica indesejada de ser de f\'acil decodifica\c {c}\~ao, pois possui apenas {26} chaves poss\'iveis, e isso faz com que no m\'aximo em {26} tentativas o c\'odigo seja decifrado. Com o intuito de dificultar a quebra do c\'odigo monoalfab\'etico foram propostas as \textit {cifras de substitui\c {c}\~ao polialfab\'eticas} em que a chave criptogr\'afica passa a ser uma \textit {palavra} ao inv\'es de um n\'umero. A ideia \'e usar as posi\c {c}\~oes ocupadas pelas letras da chave para determinar o n\'umero de posi\c {c}\~oes que devemos avan\c {c}ar para obter a posi\c {c}\~ao da letra encriptada. Vejamos, por meio de um exemplo, como funciona esse sistema criptogr\'afico. }{3}
\contentsline {subparagraph}{ Sejam ``SENHA'' a nossa chave criptogr\'afica e ``ABOBORA'' a mensagem a ser encriptada. Abaixo colocamos as letras do alfabeto com suas respectivas posi\c {c}\~oes. Observe que repetimos a primeira linha de letras para facilitar a localiza\c {c}\~ao da posi\c {c}\~ao da letra encriptada e usamos a barra para indicar que estamos no segundo ciclo. }{3}
\contentsline {subparagraph}{ Vejamos como encriptar a palavra ``ABOBORA''. Iniciamos o processo escrevendo a mensagem. Ao lado de cada letra da mensagem aparece entre par\^enteses o n\'umero que indica a sua posi\c {c}\~ao. Abaixo da mensagem escrevemos as letras da chave criptogr\'afica, repetindo-as de forma c\'iclica quando necess\'ario. Analogamente, ao lado de cada letra da chave aparece entre par\^enteses o n\'umero da posi\c {c}\~ao ocupada de cada letra, e o sinal de soma indica que devemos avan\c {c}ar aquele n\'umero de posi\c c\~oes. Ao final do processo aparecem as letras encriptadas. Entre par\^enteses est\'a a posi\c {c}\~ao resultante da combina\c {c}\~ao das posi\c {c}\~oes da mensagem e da chave. }{4}
\contentsline {subparagraph}{ Observe que a encripta\c {c}\~ao polialfab\'etica \'e mais dif\'icil de ser quebrada que a monoalfab\'etica uma vez que letras iguais n\~ao t\^em, necessariamente, a mesma encripta\c {c}\~ao. Observe que neste tipo de criptografia o emissor precisa passar a chave para o receptor da mensagem de forma segura para que o receptor possa decifrar a mensagem, isto \'e, a chave usada para encriptar a mensagem \'e a mesma que deve ser usada para decifrar a mensagem. Veremos que esse \'e justamente o ponto fraco nesse tipo de encripta\c {c}\~ao pois usa a chamada \textit {chave sim\'etrica}, ou seja, a chave usada pelo emissor para codificar a mensagem \'e a mesma usada pelo receptor para decodificar a mensagem. Nesse processo, a chave deve ser mantida em segredo e bem guardada para garantir que o c\'odigo n\~ao seja quebrado e isso requer algum tipo de contato f\'isico entre emissor e receptor. }{4}
\contentsline {subparagraph}{ Durante a Primeira Guerra Mundial o contato f\'isico para a troca de chaves era complicado, e isso estimulou a cria\c {c}\~ao de m\'aquinas autom\'aticas de criptografia. O \textit {Enigma} foi uma destas m\'aquinas e era utilizada pelos alem\~aes tanto para criptografar como para descriptografar c\'odigos de guerra. Semelhante a uma m\'aquina de escrever, os primeiros modelos foram patenteados por Arthur Scherbius em 1918. Essas m\'aquinas ganharam popularidade entre as for\c {c}as militares alem\~aes devido a facilidade de uso e sua suposta indecifrabilidade do c\'odigo. }{4}
\contentsline {subparagraph}{ O matem\'atico Alan Turing foi o respons\'avel por quebrar o c\'odigo dos alem\~aes durante a Segunda Guerra Mundial. A descoberta de Turing mostrou a fragilidade da criptografia baseada em chave sim\'etrica e colocou novos desafios \`a criptografia. O grande problema passou a ser a quest\~ao dos protocolos, isto \'e, como transmitir a chave para o receptor de forma segura sem que seja necess\'ario o contato f\'isico entre as partes? }{5}
\contentsline {subparagraph}{Em 1949, com a publica\c {c}\~ao do artigo \textit {Communication Theory of Secrecy Systems} \cite {shannon} de Shannon, temos a inaugura\c {c}\~ao da criptografia moderna. Neste artigo ele escreve matematicamente que cifras teoricamente inquebr\'aveis s\~ao semelhantes as cifras polialfab\'eticas. Com isso ele transformou a criptografia que at\'e ent\~ao era uma arte em uma ci\^encia. }{5}
\contentsline {subparagraph}{ Em 1976 Diffie e Hellman publicaram \textit {New Directions in Cryptography} \cite {newdirections}. Neste artigo h\'a a introdu\c {c}\~ao ao conceito de \textit {chave assim\'etrica}, onde h\'a chaves diferentes entre o emissor da mensagem e seu receptor. Com a assimetria de chaves n\~ao era mais necess\'ario um contato t\~ao pr\'oximo entre emissor e receptor. Neste mesmo artigo \'e apresentado o primeiro algoritmo de criptografia de chave assim\'etrica ou como \'e mais conhecido nos dias atuais \textit {Algoritmo de Criptografia de Chave P\'ublica}, o protocolo de Diffie-Hellman. }{5}
\contentsline {subparagraph}{ Um dos algoritmos mais famosos da criptografia assim\'etrica \'e o \textit {RSA}(RIVEST et al, 1983) \cite {rivest}, algoritmo desenvolvido por Rivest, Shamir e Adleman. Este algoritmo est\'a presente em muitas aplica\c {c}\~oes de alta seguran\c {c}a, como bancos, sistemas militares e servidores de internet, e ele utiliza para a gera\c {c}\~ao de chaves dois n\'umeros primos de grandeza superior a $2^{512}$ multiplicados entre si. }{5}
\contentsline {subparagraph}{ Neste trabalho ser\'a feita a exposi\c {c}\~ao detalhada da chamada criptografia RSA cl\'assica, enfatizando a parte matem\'atica relacionada \`{a} Teoria dos n\'umeros, necess\'aria para a constru\c {c}\~ao do algoritmo. }{5}
\contentsline {subparagraph}{ O maior objetivo deste artigo \'e analisar a viabilidade de uma criptografia inspirada pelo algoritmo RSA cl\'assico, a qual substitui o s n\'umeros primos pelo conjunto denominado de \textit {primos de Gauss}, resultando, assim, no que chamamos por \textit {criptografia RSA gaussiana}. Para que tal algoritmo seja vi\'avel \'e necess\'ario se adaptar uma s\'erie de propiedades relativas aos n\'umeros primos aos n\'umero primos de Gauss. Dessa forma, nossa tarefa ser\' adaptar tanto quanto o poss\'ivel os primos de Gauss \`as dmosnta\c {c}\~oes desses teoremas. }{6}
\contentsline {subparagraph}{ Como se trata de uma proposta inovadora, deixamos para trabalhos futuros uma an\'alise comparativa entre as criptografias RSA cl\'assica e a RSA gaussiana. }{6}
\contentsline {chapter}{\numberline {2}Primos e Fatora\c {c}\~ao}{7}
\contentsline {section}{\numberline {2.1}Ciclos e Restos}{7}
\contentsline {subparagraph}{ Para podermos compreender a aritm\'etica modular, precisamos come\c {c}ar entendendo o conceito de ciclicidade, que s\~ao os fatos que ocorrem sempre ap\'os um determinado per\'iodo constante. Um bom exemplo deste conceito \'e o nascer do sol, que \'e um evento que ocorre sempre ap\'os um ciclo de {24} horas, assim como o dia de seu anivers\'ario ocorre uma vez a cada ciclo de um ano. }{7}
\contentsline {subparagraph}{ O mesmo tipo de evento \'e observado com o resto dos n\'umeros inteiros. Tomemos por exemplo os restos de divis\~ao dos n\'umeros inteiros, abaixo mostrados de 1 \`a 12, pelo n\'umero inteiro {4}: }{7}
\contentsline {subparagraph}{ \'E vis\'ivel que ap\'os {4} n\'umeros o resto tende a se repetir. O mesmo feito ocorre a qualquer n\'umero inteiro $n$, onde o ciclo se repetir\'a sempre a cada $n$ itera\c {c}\~oes. Os n\'umeros que apresentam o resto {0} s\~ao conhecidos como m\'ultiplos de $n$. }{7}
\contentsline {section}{\numberline {2.2}N\'{u}meros Primos e Compostos}{7}
\contentsline {subparagraph}{ Existe um tipo especial de n\'umero que s\'o \'e m\'ultiplo, ou seja, possui resto {0}, em duas condi\c {c}\~oes, quando $n$ \'e igual a {1} ou quando ele \'e igual a $n$. A esse conjunto de n\'umeros atribui-se o nome de \textit {n\'umeros primos}. }{8}
\contentsline {subparagraph}{ \textit {Existem infinitos n\'umeros primos}, caso n\~ao acredite vamos supor que o conjunto finito de primos seja composto por $p_{1}, p_{2}, ..., p_{r} $. Considerando que o n\'umero inteiro $n=(p_{1})(p_{2})...(p_{r}) + 1$. $n$ deve possuir um fator $p$, que est\'a contido em $p_{1}, p_{2}, ..., p_{r} $, mas isso significa q $p$ divide $1$, o que \'e absurdo e prova que o conjunto n\~ao tem fim. }{8}
\contentsline {subparagraph}{ Todo o n\'umero que n\~ao \'e primo \'e chamado de \textit {N\'umero Composto}, sendo que este n\'umero composto pode ser escrito em \textit {uma combina\c {c}\~ao \'unica de fatores primos}. O processo de se descobrir estes fatores \'e chamado de \textit {fatora\c {c}\~ao} e \'e detalhado na pr\'oxima se\~A\IeC {\S }\~A\IeC {\pounds }o. }{8}
\contentsline {section}{\numberline {2.3}Fatora\c {c}\~{a}o}{8}
\contentsline {subparagraph}{ Anteriormente falamos que todo o n\'umero pode ser escrito por uma combina\c {c}\~ao de fatores primos, neste cap\'itulo vamos abordar como se pode obter estes fatores. }{8}
\contentsline {subparagraph}{ Come\c {c}amos por escolher o n\'umero inteiro $n$ ao qual iremos fatorar, em seguida testamos a sua divisibilidade por $2$, se for tente divid\'i-lo novamente por $2$, sen\~ao passa-se para o pr\'oximo n\'umero primo, o $3$. Repete-se esse procedimento at\'e chegarmos a $\sqrt {n}$, caso n\~ao achemos nenhum fator primo at\'e $\sqrt {n}$, $n$ \'e primo. }{8}
\contentsline {subparagraph}{ Quando acabamos de realizar a fatora\c {c}\~ao, chegamos a um n\'umero fatorado da forma $n = (2^{a_{1}})(3^{a_{2}}) ... (p^{a_{p}})$, todo o n\'umero inteiro pode ser escrito nessa forma, chamada forma fatorada, veja, por exemplo o $12 = (2^2)(3^1)$ e o $19 = (19^1)$. }{8}
\contentsline {subparagraph}{ Essa forma fatorada nos \'e formalmente apresentada pelo \textit {Teorema da Fatora\c {c}\~ao \'Unica}. Ele nos diz que dado um n\'umero inteiro $n\geq 2$ pode-se escrev\^e-lo de forma \'unica como: }{8}
\contentsline {paragraph}{ onde $1 < p_1 < ... < p_k $ s\~ao primos e $e_1, ..., e_k$ s\~ao inteiros. }{9}
\contentsline {subparagraph}{ Mesmo algoritmo da fatora\c {c}\~ao sendo t\~ao simples de se compreender, ele \'e demorado at\'e para os mais modernos computadores. Para se ter uma ideia disto, um computador comum executa cerca de {50} divis\~oes por segundo, para se calcular com certeza que um n\'umero pr\'oximo a $10^{100}$ \'e primo ele levaria cerca de {317} decilh\~oes de anos. Essa demora computacional que torna os primos t\~ao atraentes a criptografia, pois sua multipli\c {c}\~ao \'e f\'acil para se obter o resultado, mas muito complexa para que se descubram quais os n\'umeros envolvidos nela apenas com o resultado final. }{9}
\contentsline {chapter}{\numberline {3}Opera\c {c}\~oes Modulares}{10}
\contentsline {section}{\numberline {3.1}Defini\c {c}\~ao de m\'odulo}{10}
\contentsline {subparagraph}{ J\'a lhe foi apresentado anteriormente o conceito da ciclicidade para a defini\c {c}\~ao de restos, neste cap\'itulo iremos nos aprofundar mais sobre esse conceito, estudando as propiedades necess\'arias da aritm\'etica modular para a elabora\c {c}\~ao da cripotgrafia RSA. }{10}
\contentsline {subparagraph}{ Um dos conceitos mais importantes da aritm\'etica modular \'e o de congru\^encia, representado pelo s\'imbolo $\equiv $. Talvez o exemplo mais comum de congru\^encia em nossas vidas sejam os dias da semana, embora o n\'umero do dia venha a variar ao longo do m\^es, sempre ap\'os {7} dias voltar\'a a ser domingo, por exemplo, logo a semana \'e uma congru\^encia de m\'odulo 7. }{10}
\contentsline {subparagraph}{ Para exemplificar vamos supor que primeiro domingo deste m\^es foi dia 4, e o \'ultimo ser\'a dia 25, logo temos que }{10}
\contentsline {subparagraph}{ Fique claro que o que tornou $25$ congruente a $4$ no m\'odulo $7$ n\~ao foi o fato de ca\'irem no mesmo dia, isso \'e apenas um consequ\^encia, o que os torna congruentes \'e o fato de que divididos pelo m\'odulo, no caso $7$, eles apresentam o mesmo resto. Esse fato n\~ao se repete, por exemplo, se o m\'odulo for 5, neste caso $ 4 \equiv 4 (mod 5)$ e $ 25 \equiv 0 (mod 5)$. }{10}
\contentsline {section}{\numberline {3.2}Propiedades das congru\^encias}{11}
\contentsline {subparagraph}{ Assim como as igualdades e desigualdades, as congru\^encias tamb\'em possuem uma listagem de propiedades em suas opera\c {c}\~oes. Ao longo desta se\c {c}\~ao lhe ser\~ao demonstradas essas propiedades. Fique atento pois as propiedades das congru\^encias nos facilitar\~ao a compreens\~ao de alguns conceitos importantes do algoritmo RSA mais a frente. }{11}
\contentsline {subparagraph}{ A primeira propiedade das congru\^encias, e a mais simples dela, \'e a \textit {reflexiva}, onde se diz que um n\'umero sempre \'e congruente a si mesmo. Para termos certeza vamos tomar um n\'umero qualquer $a$, sendo $a \equiv a (mod n)$, \'e equivalente dizermos que $a-a \equiv 0 (mod n)$. Por $0$ ser m\'ultiplo de qualquer n\'umero podemos confirmar que $a \equiv a (mod n)$. }{11}
\contentsline {subparagraph}{ A propiedade \textit {sim\'etrica} nos diz que se $a \equiv b (mod n)$, $b \equiv a (mod n)$. A afirma\c {c}~ao anterior ode ser escrito como se $a-b$ \'e m\'ultiplo de $n$, mas para isso deve ocorrer algum n\'umero $k$ que equivala \`a: }{11}
\contentsline {paragraph}{ Caso multipliquemos esta equa\c {c}\~ao por $-1$, vamos obter: }{11}
\contentsline {paragraph}{ Que nos prova que $b-a$ \'e m\'ultiplo de $n$, logo $b \equiv a (mod n)$. }{11}
\contentsline {subparagraph}{ A terceira propiedade das congru\^encias \'e a \textit {transitiva}, onde se diz que se $a \equiv b (mod n)$ e $b \equiv c (mod n)$, $a \equiv c (mod n)$. Para prov\'a-la vamos observar as equa\c {c}\~oes }{11}
\contentsline {paragraph}{ Sabendo que $k$ e $l$ s\~ao inteiros escolhidas de forma adequada as equa\c {c}\~oes, podemos somar as equa\c {c}\~oes, resultando em: }{11}
\contentsline {paragraph}{ Que pode ser simplificada em: }{12}
\contentsline {paragraph}{ Essa equa\c {c}\~ao equivale em valor a $a \equiv c (mod n)$, logo a propriedade transitiva \'e v\'alida. }{12}
\contentsline {chapter}{\numberline {4}Inversos Modulares}{13}
\contentsline {section}{\numberline {4.1}Inversos modulares}{13}
\contentsline {subparagraph}{ Nosso objetivo com o decorrer deste cap\'itulo \'e o de explicar a opera\c {c}\~ao matem\'atica mais importante para para o algoritmo RSA. Para podermos comprend\^e-la vamos relembrar do cenceito ensinado no col\'egio de inverso multiplicativo, que consiste em obter o n\'umero que multiplicado a um n\'umero $n$ qualquer resulte em $1$. A opera\c {c}\~ao do inverso modular parte do mesmo princ\'ipio. }{13}
\contentsline {subparagraph}{ Vamos supor que queremos obter o inverso modular de $6$ para o m\'odulo $7$, o que n\'os teremos que fazer ent\~ao \'e encontrar qual o n\'umero que multiplicado por $6$ tem resto $1$ quando dividido por $7$. Come\c {c}amos pelo $1$, teremos que $6 \cdot 1 = 6$, $6 \equiv 6 (mod7)$. Com $2$ o resultado ser\'a $12$, logo $12 \equiv 5 (mod7)$, que para n\'os tamb\'em n\~ao serve. Tentando o $3$ obtemos $4$ e com $4$ obtemos $3$. Com o $5$ nosso retorno ser\'a $2$. Finalmente quando chegamos ao $6$ n\'os temos que $6 \cdot 6 = 36$, $36 \equiv 1 (mod 7)$. Com isso podemos concluir que o inverso multiplicativo de $6$ no m\'odulo $7$ \'e o pr\'opio $6$. }{13}
\contentsline {subparagraph}{ Para simplificar o que foi dito acima, podemos dizer a opera\c {c}\~ao de inverso multiplicativo no m\'odulo $n$ para $a$ consiste em encontar um n\'umero $a'$ tal que: }{13}
\contentsline {section}{\numberline {4.2}Inexist\^encia e exist\^encia de inversos}{14}
\contentsline {subparagraph}{ Antes de come\c {c}armos vamos tentar calcular o inverso multiplicativo de $2$ no m\'odulo $8$, vamos l\'a: }{14}
\contentsline {subparagraph}{ N\~ao encontramos nenhuma resposta pois, simplesmente, n\~ao h\'a. Antes que se pergunte o motivo de n\~ao tentarmos com n\'umeros maiores que $7$, \'e v\'alido lembrar que a partir do $8$ ter\'iamos a repeti\c {c}\~ao de resultados por conta das congru\^encias. }{14}
\contentsline {subparagraph}{ A opera\c {c}\~ao de inverso multiplicativo s\'o possui resultado em casos onde o n\'umero $a$ ao qual queremos calcular o inverso e o m'odulo s\~ao \textit {primos entre si}, ou seja, n\~ao possuam nenhum fator em comum. Por conta disso usamos os n\'umeros primos no algoritmo RSA. }{14}
\contentsline {subparagraph}{ Para comprovar o que foi dito acima, vamos tomar um n\'umero $a$, tal que }{14}
\contentsline {paragraph}{ isso pode ser traduzido em linguagem humana como $n$ divide $ a \cdot a' - 1$. Isso em linguajar matem\'atico pode ser escrito como: }{14}
\contentsline {paragraph}{ como estamos atr\'as de saber se $a$ e $n$ n\~ao possuem fator comum, ent\~ao h\'a de haver um $k$ inteiro para a equa\c {c}\~ao acima. Nosso primeiro passo para provar isso ser\'a de se criar o conjunto $V(a,n)$, esse conjunto \'e formado por inteiros positivos e pode ser escrito como }{14}
\contentsline {subparagraph}{ Em um primeiro momento este conjunto e esta nova f\'ormula podem parecer estranhos ao que se via antes, mas se comprovarmos que $ 1 \in V(a,n)$, conclu\'imos que devem haver dois inteiros $x_0$ e $y_0$, ou se preferir $a'$ e $k$, logo: }{15}
\contentsline {subparagraph}{ Uma das propiedades deste conjunto \'e a de $n$ pertencer a ele quando $x = a' = 0$ e $y = k = 1$. Isto significa que os inteiros que podem completar a equa\c {c}\~ao est\~ao entre $m$ e $n$. Mas para podermos dar essa demonstra\c {c}\~ao como completa, precisamos provar que $m = 1$. Como $a$ e $n$ s\~ao primos entre si, basta mostrar que $m$ divide ambos. Vamos come\c {c}ar assumindo que $m \in V(a,m)$ , logo devem existir $x_1$ e $y_1$ tais que: }{15}
\contentsline {paragraph}{ Caso venhamos a dividir $n$ por $m$, obtemos: }{15}
\contentsline {paragraph}{ Que pode ser organizada como: }{15}
\contentsline {subparagraph}{ Com isso podemos concluir que $r \in V(a,n)$, como $r$ \'e o resto da divis\~ao de $n$ por $m$, de modo que $r = 0$ ou $r \not =0$. $r \not =0$ \'e absurdo por conta de $r<m$, com $m$ divisor de $n$, por $m$ ser o menor elemento de $V(a,n)$. Logo s\'o nos resta conferir se $r = 0$, o que prova que $m$ divide $n$. Pode se provar de forma semelhante que $m$ divide $a$. }{15}
\contentsline {section}{\numberline {4.3}Um teorema e um corol\'ario}{15}
\contentsline {subparagraph}{ Com base em tudo que j\'a foi lido e provado anteriormente neste cap\'itulo podems concluir o seguinte teorema: }{15}
\contentsline {paragraph}{ \textit {Sejam $a<n$ inteiros positicos. O res\'iduo $a$ em inverso no m\'odulo $n$ se, e somente se, $a$ e $n$ n\~ao possuem fatores primos em comum.} }{15}
\contentsline {paragraph}{ Esta informa\c {c}\~ao nos ser\'a muito \'util mais a frente. Outra coisa muito importante para nosso prosseguimento \'e o seguinte corol\'ario: }{16}
\contentsline {paragraph}{ \textit {Sejam $a<n$ inteiros positivos sem fatores comuns, se :} }{16}
\contentsline {paragraph}{ \textit {ent\~ao:} }{16}
\contentsline {subparagraph}{ Nos cap\'itulos seguintes poderemos ver como iremos aplicar estas propiedades, que nos ser\~ao muito \'uteis para agilizar nossos c\'alculos. }{16}
\contentsline {chapter}{\numberline {5}T\'ecnicas para facilitar opera\c {c}\~oes}{17}
\contentsline {section}{\numberline {5.1}Teorema chin\^es do resto}{17}
\contentsline {chapter}{Bibliografia}{18}
\select@language {brazil}
\select@language {brazil}
\select@language {brazil}
\select@language {brazil}
