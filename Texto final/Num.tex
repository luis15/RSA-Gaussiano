\pagestyle{fancy}
\fancyhead[C]{\textsl{1. Um passeio pela Teoria de N\'umeros}}
\fancyhead[R]{\thepage}
\fancyfoot[C]{}


\chapter{Um passeio pela Teoria de N\'umeros}
\label{Num}

A teoria de n\'umeros \'e umas das mais antigas \'areas da matem\'atica e dedica-se ao estudo relacionado a propriedades relativas aos n\'umeros inteiros tais como: a quest\~ao da fatora\c{c}\~ao, m\'aximo divisor comum, primalidade, entre outras. Ao longo deste cap\'itulo mostraremos os principais resultados de teoria de n\'umeros essenciais para a compreens\~ao do m\'etodo de criptografia de chave p\'ublica conhecido como RSA.

\section{N\'umeros Primos e Fatora\c{c}\~ao \'Unica}

Os n\'umeros primos ocupam lugar importante tanto na teoria de n\'umeros quanto na criptografia RSA: na primeira por serem capazes de gerar todos os elementos do conjunto dos n\'umeros inteiros e suas consequentes propriedades; na segunda pelo fato de formarem um conjunto infinito e permiir com isso que se tome um primo de dimens\~ao estrondosa para codificar uma mensagem, consequentemente dificultando que um c\'odigo seja decifrado por terceiros em tempo razo\'avel, como mostraremos ao longo desta monografia.

Os primos atuam como \'atomos dentro do conjunto dos n\'umeros inteiros no sentido em que todo n\'umero pode ser escrito de forma 
\'{u}nica como um produto de primos. Esse fato \'e consequ\^encia do chamado \textit{Teorema da Fatora\c{c}\~ao \'Unica} tamb\'em conhecido por \textit{Teorema Fundamental da Aritm\'etica}. Al\'em de ser um resultado fundamental para a teoria de n\'umeros, ele tamb\'em \'e um dos pilares da criptografia RSA, pois a decodifica\c{c}\~ao de uma mensagem vai passar pela fatora\c{c}\~ao de um n\'umero. Para demonstrar esse teorema \'e preciso ter a disposi\c{c}\~ao o seguinte teorema. 


\begin{Th}
[Teorema de divis\~ao]\label{teo.div}
Sejam $a$ e $b$ inteiros positivos. Existem n\'umeros inteiros $q$ (quociente) e $r$ (resto) tais que:	
	\begin{center}
		$a=bq+r$ e $0\leq r <b$
	\end{center}
Al\'em disso, os valores de $q$ e $r$ satisfazendo as rela\c{c}\~oes acima s\~ao \'unicos.
\end{Th} 

\begin{proof}
Confira em \cite{cou:2014}, se\c{c}\~ao 3 do cap\'itulo 1, p. 22.
\end{proof}

O teorema acima faz duas afirma\c{c}\~oes: a primeira que o quociente e o resto da divis\~ao sempre existem; a segunda, que o quociente e o resto s\~ao \'unicos. A garantia da unicidade \'e o ponto crucial na aplica\c{c}\~ao \`a criptografia RSA, pois assim temos a garantia de que uma mensagem possa ser decodificada de maneira \'unica. Um outro resultado 
igualmente importante \'e o \textit{Algoritmo de Euclides} mais conhecido como m\'etodo para se calcular o m\'aximo divisor comum entre dois 
n\'umeros. Esse resultado \'e importante para definir o que entendemos por n\'umeros primos e consequentemente para o teorema da fatora\c{c}\~ao \'unica, o qual mostra como expressar um n\'umero em fatores primos de forma \'unica. 

Descri\c{c}\~{a}o do \textit{algoritmo euclidiano}: 

\begin{itemize}
		\item \textbf{Entrada - etapa 1:} divida $a$ por $b$ e ache o resto $r_{1}$;
						\begin{itemize}
								\item Se $r_{1}=0$, escreva ``$mdc(a,b)=1$'' e pare o processo.
								\item Se $r_{1}\neq 0$, volte para a entrada.
						\end{itemize}
		\item \textbf{Entrada - etapa 2:} divida $b$ por $r_{1}$ e ache o resto $r_{2}$;  
						\begin{itemize}
								\item Se $r_{2}=0$, escreva $mdc(a,b)=r_{1}$ e pare o processo.
								\item Se $r_{2}\neq 0$, volte para a entrada.
						\end{itemize}
		\item \textbf{Entrada - etapa 3:} divida $r_{1}$ por $r_{2}$ e ache o resto $r_{3}$;
					\begin{itemize}
								\item Se $r_{3}=0$, escreva $mdc(a,b)=r_{2}$ e pare o processo.
								\item Se $r_{3}\neq 0$, volte para a entrada.
					\end{itemize}
		\item E assim por diante.
\end{itemize}

O algoritmo acima produz a seguinte sequ\^{e}ncia de divis\~{o}es, e o processo segue at\'{e}
que se obtenha um resto igual a zero, nesse caso o procedimento termina:
\[
\begin{array}{rclcl}
a   		& =      & bq_{1}+r_{1} 			    & \textrm{ e } & 0\leq r_{1}<b       \\
b   		& =      & r_{1}q_{2}+r_{2} 	    & \textrm{ e } & 0\leq r_{2}<r_{1}       \\
r_{1}		& =      & r_{2}q_{3}+r_{3} 	    & \textrm{ e } & 0\leq r_{3}<r_{2}       \\
r_{2}   & =      & r_{3}q_{4}+r_{4} 	    & \textrm{ e } & 0\leq r_{4}<r_{3}       \\
        & \vdots &     		          	    &              &                     \\
r_{k-2} & =      & r_{k-1}q_{k}+r_{k}     & \textrm{ e } & 0\leq r_{k}<r_{k-1} \\				
r_{k-1} & =      & r_{k}q_{k+1}+ 0        & \textrm{ e } & 0\leq 0    <r_{k} \\		
\end{array}
\]  

As informa\c{c}\~{e}s relevantes obtidas no procedimento podem ser organizado em uma tabela do seguinte modo:

\[
\begin{array}{|c|c|c|c|c|c|c|}\hline
	a     & b     & r_{1} & r_{2} & \cdots & r_{k-1} & r_{k}\\ \hline
	r_{1}	& r_{2} & r_{3} & r_{4} &        & 0       &  \\ \hline
\end{array}
\]

A constru\c{c}\~{a}o da tabela se inicia com a inser\c{c}\~{a}o dos n\'{u}meros $a$ e $b$ na linha de cima e em seguida preenchemos
a o primeiro bloco da linha de baixo com o valor do resto da divis\~{a}o de $a$ por $b$. Se o resto for diferente de zero, 
inserimos $r_{1}$ no terceiro bloco da linha de cima e fazemos a divis\~{a}o de $b$ por $r_{1}$ e escrevemos
$r_{2}$ no segundo bloco da linha de baixo.
O processo termina quando obtiver um zero na linha de baixo da tabela e o m\'{a}ximo divisor comum ser\'{a} o 
\'{u}ltimo valor inserido na primeira linha da tabela antes do processo terminar. 

Vejamos como exemplo, como obter o m\'{a}ximo divisor comum entre 1234 e 54 usando o algoritmo acima. 

\[
\begin{array}{|c|c|c|c|c|c|}\hline
	1234 & 54 & 46 & 8 & 6 & 2 \\ \hline
	46   & 8  & 6  & 2 & 0 &   \\ \hline
\end{array}
\]

Para a criptografia RSA ser\'{a} conveniente trabalhar com uma vers\~ao estendida do m\'etodo descrito acima o qual 
chamamos \textit{algoritmo euclidiano estendido}.
Na vers\~{a}o estendida v\~{a}o aparecer dois n\'{u}meros que ser\~{a}o importantes para obter inverso multiplicativo 
na aritm\'{e}tica modular, como veremos na pr\'{o}xima se\c{c}\~{a}o.


\begin{Th}[Algoritmo Euclidiano Estendido]\label{alg.eucl.est.}
Sejam $a$ e $b$ inteiros positivos e seja $d$ o m\'aximo divisor comum entre $a$ e $b$. Existem
inteiros $\alpha$ e $\beta$ tais que:
	$$\alpha\cdot a+\beta\cdot b=d$$
\end{Th}


Diferente do teorema de divis\~ao, o algoritmo euclidiano estendido n\~ao garante a unicidade 
com rela\c{c}\~ao aos inteiros $\alpha$ e $\beta$, mas veremos que esse problema acaba sendo 
contornado por termos \`{a} disposi\c{c}\~ao um m\'etodo eficiente para calcular esses n\'umeros.
A vers\~{a}o do algoritimo que vamos apresentar \'{e} devida a Donald Knuth, um grande nome 
para a computa\c{c}\~{a}o, conforme afirma Coutinho em \cite{cou:2014}.

Vejamos como o m\'{e}todo estendido pode ser descrito:

\[
\begin{array}{rclcl}
a   		& =      & bq_{1}+r_{1} 			    & \textrm{ e } & r_{1}=ax_{1}+by_{1}       \\
b   		& =      & r_{1}q_{2}+r_{2} 	    & \textrm{ e } & r_{2}=ax_{2}+by_{2}     \\
r_{1}		& =      & r_{2}q_{3}+r_{3} 	    & \textrm{ e } & r_{3}=ax_{3}+by_{3}     \\
r_{2}   & =      & r_{3}q_{4}+r_{4} 	    & \textrm{ e } & r_{4}=ax_{4}+by_{4}     \\
        & \vdots &     		          	    &  \vdots      &                     \\
r_{k-3} & =      & r_{k-2}q_{k-1}+r_{k-1} & \textrm{ e } & r_{k-1}=ax_{k-1}+by_{k-1} \\				
r_{k-2} & =      & r_{k-1}q_{k}+ 0        & \textrm{ e } & r_{k}=0 \\		
\end{array}
\]

Os n\'{u}meros $x_{1}, x_{2}, \cdots, x_{k-1}$ e $y_{1}, y_{2}, \cdots, y_{k-1}$ s\~{a}o inteiros a
serem determinados durante o processo pelas seguintes express\~{o}es:

$$x_{j}=x_{j-2}-q_{j}x_{j-1}\textrm{ \ \ e \ \ }  y_{j}=y_{j-2}-q_{j}y_{j-1}$$

As informa\c{c}\~{o}es obtidas acima podem ser inseridas numa tabela da seguinte forma:
\[
\begin{array}{|c|c|c|c|}\hline
\textrm{ Restos } & \textrm{ Quocientes } & x       & y \\ \hline
				a 	      & \ast     							& x_{-1}  & y_{-1} \\ \hline
				b  			  & \ast     							& x_{0}   & y_{0} \\ \hline
				r_{1}     & q_{1}   					 	  & x_{1}   & y_{1} \\ \hline
				r_{2}     & q_{2}    							& x_{2}   & y_{2} \\ \hline
				r_{3}     & q_{3}    							& x_{3}   & y_{3} \\ \hline  
				\vdots    & \vdots   							& \vdots  & \vdots \\ \hline
				r_{k-2}   & q_{k-2}  							& x_{k-2} & y_{k-2} \\ \hline
				0         & q_{k-1}  							& \ast    & \ast    \\ \hline
\end{array}
\]

Para fins pr\'{a}ticos iniciamos o processo fixando os seguintes valores para as vari\'{a}veis inciais
que n\~{a}o aparecem no processo: $x_{-1}=y_{0}=1$ e $x_{0}=y_{-1}=0$. Com isso o processo se inicia e 
uma sequ\^{e}ncia de divis\~{o}es \'{e} gerada at\'{e} que se obtenha resto zero, finalizando o processo. 
A partir da\'{i} os valores $\alpha=x_{k-2}$ e $\beta=y_{k-2}$ que aparecem no 
enunciado do teorema s\~{a}o determinados. Para detalhes acerca da demonstra\c{c}\~{a}o do m\'{e}todo descrito acima recomendamos 
a se\c{c}\~{a}o 6 do cap\'{i}tulo 1 de \cite{cou:2014}. 

Vejamos o exemplo de como calcular o m\'{a}ximo divisor comum de 1234 e 54 usando o algoritmo estendido:

\[
\begin{array}{|c|c|c|c|}\hline
\textrm{ Restos } & \textrm{ Quocientes } & x       								& y \\ \hline
				1234 	    & \ast     							& 1      									& 0 \\ \hline
				54  			& \ast     							& 0       								& 1 \\ \hline
				46        & 22   					 	  		& x_{1}=1-22\cdot 0 = 1   & y_{1}=0-22\cdot 1=-22 \\ \hline
				8     		& 1    									& x_{2}=0-1\cdot 1=-1     & y_{2}=1-1(-22)=23 \\ \hline
				6    	  	& 5    									& x_{3}=1-5(-1)=6         & y_{3}=-22-5\cdot 23=-137 \\ \hline  
				2    			& 1   									& x_{4}=-1-1\cdot 6=-7    & y_{4}=23-1\cdot(-137)=160 \\ \hline
				0   			& 3  										& \ast                    & \ast    \\ \hline
\end{array}
\]

Da\'{i}, temos que $\alpha=-7$ e $\beta=160$ e pelo Teorema~\ref{alg.eucl.est.} segue que
$mdc(1234,54)=(-7)\cdot(1234)+(160)\cdot(54)=2$, como esper\'{a}vamos.

Como dissemos, a vantagem em usar o algoritmo acima est\'{a} no fato de termos um procedimento para determinar os n\'{u}meros
$\alpha$ e $\beta$, que como veremos ser\~{a}o \'{u}teis para o RSA.

Agora, estamos em condi\c{c}\~{o}es de definir o que entendemos por n\'umeros primos para ent\~ao atingir nossa meta com este 
cap\'itulo: o teorema da fatora\c{c}\~ao \'unica.

\begin{Df}
Um n\'umero inteiro $p$ \'e \textit{primo} se $p\neq \pm 1$ e os \'unicos divisores de $p$ s\~ao $\pm 1$ e $\pm p$. 
\end{Df} 

S\~ao exemplos de n\'umeros primos: $\pm 2$, $\pm 3$, $\pm 5$, $\pm 7$, $\pm 11$, $\pm 13$, etc.

Um n\'umero inteiro, diferente de $\pm 1$, que n\~ao \'e primo \'e chamado \textit{composto}. Observe que os n\'umeros $1$ e $-1$ n\~ao s\~ao nem primos e nem compostos. A exclus\~ao desses n\'umeros do conjunto dos primos tem a finalidade de garantir a unicidade da fatora\c{c}\~ao no teorema a seguir. Um outro aspecto a se destacar acerca desse par de n\'umeros \'e que eles s\~ao os \'unicos em $\mathbb{Z}$ que admitem inverso multiplicativo. Falaremos mais sobre esse assundo mais adiante.

\begin{Th}
[Teorema da Fatora\c{c}\~ao \'Unica]\label{fat.unica} 
Dado um inteiro positivo $n\geq 2$ podemos sempre escrev\^e-lo, de modo \'unico, na forma
$$n=p_{1}^{e_1}\times p_{2}^{e_2}\times\cdots\times p_{k}^{e_k}$$
onde $1<p_1<p_2<p_3<\cdots<p_k$ s\~ao n\'umeros primos e $e_1, \cdots, e_k$ s\~ao inteiros positivos.
\end{Th}
\begin{proof}
	Veja cap\'{i}tulo 2 em \cite{cou:2014}.
\end{proof}

No teorema acima, os expoentes $e_i$, para $1\leq i\leq k$ s\~ao chamados de \textit{multiplicidades}, pois indicam a quantidade de vezes que um mesmo n\'umero primo ocorre na fatora\c{c}\~ao. A prova de que \'e sempre poss\'ivel encontrar os fatores usados para decompor o n\'umero em fatores primos consiste no procedimento para fatorar um n\'umero, esse procedimento \'e chamado \textit{Algoritmo de Euclides}: trata-se do m\'etodo que se aprende na escola para fatorar
um n\'umero e que n\~ao iremos detalhar aqui. Como bem sabemos, esse m\'etodo \'e bastante ineficaz quando pensamos em n\'umeros muito grande, pois pode requerer que se realize uma sequ\^encia bem grande de divis\~oes. A prova garante que o procedimento termina, mas o que se nota \'e que tal procedimento \'e muito ineficiente no sentido em que demanda muito tempo para se chegar a uma resposta dependendo do n\'umero que desejamos fatorar. Na literatura existem v\'arios algoritmos de fatora\c{c}\~ao que tornam o m\'etodo mais eficiente, no entanto nenhum desses m\'etodos funciona bem para todos os n\'umeros inteiros. A criptografia RSA aproveita a inefici\^encia dos m\'etodos para fatorar um n\'umero para garantir a seguran\c{c}a do seu sistema. \'E um problema em aberto saber se existe ou n\~ao um m\'etodo r\'apido para fatorar n\'umeros inteiros.  

A demonstra\c{c}\~ao do teorema acima requer uma s\'erie de resultados acerca de n\'umeros primos os quais detalharemos abaixo. O interesse em apresentar as demonstra\c{c}\~oes de tais resultados \'e devido ao fato de estarmos interessados em adaptar tais provas para os primos de Gauss, cujo objetivo \'{e} compreender as dificuldades para implementar um m\'etodo de criptografia RSA baseado em primos de Gauss. 

\begin{Th}\label{propriedade_de_primos}
Sejam $a$ e $b$ inteiros positivos e suponhamos que $a$ e $b$ s\~ao primos entre si.
\begin{enumerate}
\item Se $b$ divide o produto $a\cdot c$ ent\~ao $b$ divide $c$.
\item Se $a$ e $b$ dividem $c$ ent\~ao o produto $a\cdot b$ divide $c$.
\end{enumerate}
\end{Th}

\begin{proof}

\begin{enumerate}
\item Se $a$ e $b$ s\~ao primos entre si, ent\~ao o m\'aximo divisor comum entre $a$ e $b$ \'e 1, isto \'e,
$mdc(a,b)=1$. Pelo algoritmo euclidiano estendido (Teorema~\ref{alg.eucl.est.}), temos que existem inteiros 
$\alpha$ e $\beta$ tais que $\alpha\cdot a+\beta\cdot b=1$. Ent\~ao, multiplicando toda a express\~ao por $c$ 
temos que: 
$$\alpha\cdot a\cdot c+\beta\cdot b \cdot c=c\eqno(1.1)$$ 

Dado que $b$ divide $a\cdot c$ e $b$ divide $c\cdot b$, ent\~ao $b$ divide $\alpha\cdot ac+\beta\cdot bc$. Portanto, 
a partir da igualdade (1.1) temos que $b$ divide $c$.

\item Se $a$ divide $c$, ent\~ao existe $t\in \mathbb{Z}$ tal que $c=a\cdot t$. Como, por hip\'otese, $b$ divide $c$ e $a$ e $b$ s\~ao primos entre si, ent\~ao $b$ tem que dividir $t$. Logo, para algum $t$ vale que $t=b\cdot k$. Portanto, $c=a\cdot t=a(b\cdot k)=(a\cdot b)k$ \'e divis\'ivel por $a\cdot b$.  	
\end{enumerate}	
\end{proof}

\begin{Th}[Propriedade Fundamental dos Primos]\label{fundprimos}
Seja $p$ um n\'umero primo e sejam $a$ e $b$ inteiros positivos. 
Se $p$ divide o produto $a\cdot b$ ent\~ao $p$ divide $a$ ou $p$ divide $b$. 
\end{Th}

\begin{proof}
Se $a$ e $p$ n\~ao forem primos entre si ent\~ao o m\'aximo divisor comum entre eles \'e $p$, logo $p$ divide $a$. Suponhamos que $a$ e $p$ s\~ao primos entre si, isto \'e, $mdc(p,a)=1$. Como, por hip\'otese, $p$ divide $a\cdot b$, ent\~ao pelo Teorema \ref{propriedade_de_primos} segue que $p$ divide $b$.
\end{proof}

Estamos interessados, agora, em mostrar que a lista de primos \'e infinita, para tal vejamos o seguinte resultado intermedi\'ario.

\begin{Th}[Exist\^encia de Divisor Primo]\label{divisor_primo}
Se $n$ \'e um n\'umero inteiro positivo composto, ent\~ao $n$ tem um divisor primo
$p$ tal que $p\leq\sqrt{n}$.
\end{Th}

\begin{proof}
Se $n$ \'e um n\'umero composto e positivo, podemos supor que $n=a\cdot b$, com $1<a\leq b$.
\begin{enumerate}
\item De $1<a$, temos que existe um primo $p$ que divide $a$ (Teorema~\ref{fat.unica}), com $p\leq a$, da\'i $p^2\leq a^2$.
\item De $a\leq b$ temos que $a^2\leq a\cdot b=n$
\end{enumerate}
De (1) e (2) segue que $p^2\leq n$, logo $p\leq\sqrt{n}$.
\end{proof}

\begin{Th}[Infinidade de Primos]\label{inf.primos}
Existe uma quantidade infinita de n\'umeros primos.
\end{Th}

\begin{proof}
Suponha, por redu\c{c}\~ao ao absurdo, que existe apenas uma quantidade finita de n\'umeros primos: $p_1, p_2,\cdots p_n$. Tome $a=1+p_1\times p_2\times \cdots \times p_n$ um n\'umero inteiro. Claramente $a>p_i$ para cada $1\leq i\leq n$, logo $a$ deve ser um n\'umero composto, caso contr\'ario a lista acima estaria incompleta. Como $a$ \'{e} composto, pelo Teorema~\ref{divisor_primo} existe um primo $p_i$ tal que 
divide $a$. Dado que $p_i$ divide $p_1\times p_2\times \cdots \times p_n$ e divide $a$, ent\~ao $p_1$ divide $1$. Absurdo, pois o \'unico divisor de $1$ \'e ele mesmo. Portanto, \'e falso supor que a lista de primos seja finita, logo ela deve ser infinita.
\end{proof}

Existe, ainda, um outro debate acerca de como gerar os n\'umeros primos. Existem diversos m\'etodos para gerar os primos, como o Crivo 
de Erat\'ostenes, o mais antigo deles, mas n\~ao envolve nenhuma f\'ormula espec\'ifica. No entanto, todos esses 
m\'etodos mostram-se ineficazes, como mostra Coutinho em \cite{cou:2014}.

Como vimos, o Teorema~\ref{fat.unica} garante que um n\'umero pode ser decomposto
em fatores primos de forma \'unica e o Teorema~\ref{inf.primos} garante a exist\^{e}ncia de uma infinidade de n\'umeros primos, no entanto, 
os procedimentos atrelados a esses resultados s\~ao todos muito ineficientes em termos computacionais. Para implementar a criptografia RSA, como iremos trabalhar com n\'{u}meros muito grandes, vamos precisar denot\'{a}-los por meio de pot\^{e}ncias e isso requer m\'{e}todos 
eficazes para trabalhar com esses n\'{u}meros, por essa raz\~ao vamos precisar da aritm\'{e}tica modular.  


\section{Aritm\'{e}tica Modular}

Para compreender a intui\c{c}\~{a}o por tr\'{a}s da aritm\'{e}tica modular \'{e} interessante pensar na ideia de \textit{ciclicidade}, 
isto \'{e}, em
fatos que ocorrem ap\'{o}s um determinado per\'{i}odo constante ou ciclo. Por exemplo, o nascer do sol \'{e} um evento que 
permite marcar um ciclo, pois ocorre sempre ap\'{o}s um ciclo de 24 horas; a data de seu anivers\'{a}rio \'{e} outro evento que permite marcar um ciclo, pois ocorre a cada 12 meses; e assim por diante. Trabalhar com objetos que t\^{e}m um corportamento c\'{i}clico requer que tenhamos uma nova forma de operar, pois quando somamos 13 com 15 o resultado pode ser 4 se estivermos pensando em termos de horas. Quando termina um ciclo de 24 horas, nesse mesmo instante inicia-se um novo ciclo (do dia seguinte). A repeti\c{c}\~{a}o de uma mesma hora indica o completamento de um ciclo (24 horas) a partir do ponto estabelecido como marco inicial. 

Quando mostramos o processo de codifica\c{c}\~{a}o e de decodifica\c{c}\~{a}o de um c\'{o}digo em 
\textit{cifras de substitui\c{c}\~{a}o polialfab\'{e}ticas} voc\^{e} deve ter notado que precisamos repetir o alfabeto 
a fim de podermos operar com as posi\c{c}\~{o}es ocupadas por uma determinada letra do alfabeto. A repeti\c{c}\~{a}o do alfabeto 
foi usada para mostrar as diferentes posi\c{c}\~{o}es ocupadas por uma mesma letra. Observe que h\'{a} nesse processo o 
estabelecimento de um ciclo determinado pela quantidade de letras do alfabeto.

A partir dos ciclos podemos construir classes de n\'{u}meros representando as poss\'{i}veis marca\c{c}\~{o}es (inteiras). Por exemplo,  
no caso das horas temos as seguintes classes:  

\begin{itemize}
	\item $0h=\{x\in\mathbb{N}: x=0+24\}=\{0, 24, 48, 72, \cdots\}$ 
	\item $1h=\{x\in\mathbb{N}: x=1+24\}=\{1, 25, 49, 73, \cdots\}$
	\item $2h=\{x\in\mathbb{N}: x=2+24\}=\{2, 26, 50, 74, \cdots\}$
	\item $\vdots$
	\item $23h=\{x\in\mathbb{N}: x=23+24\}=\{23, 47, 71, 95, \cdots\}$
\end{itemize}

No exemplo das posi\c{o}\~{e}es ocupadas pelas letras do alfabeto temos as seguintes classes: 

\begin{itemize}
	\item $A=\{x\in\mathbb{N^*}: x=1+26\}=\{1, 27, 53, 79, \cdots\}$ 
	\item $B=\{x\in\mathbb{N^*}: x=2+26\}=\{2, 28, 54, 80, \cdots\}$
	\item $C=\{x\in\mathbb{N^*}: x=3+26\}=\{3, 29, 55, 81, \cdots\}$
	\item $\vdots$
	\item $Z=\{x\in\mathbb{N^*}: x=25+26\}=\{25, 51, 77, 103, \cdots\}$
\end{itemize}

Observe, pelos exemplos acima, que cada elemento do conjunto indica o marco inicial da contagem, isto \'{e}, cada elemento do conjunto indica a mesma hora em dias distintos, ou a mesma letra do alfabeto mas em ciclos distintos.

Ser\'{a} interessante nomearmos tais classes apenas por n\'{u}meros ao inv\'{e}s de sua denota\c{c}\~{a}o intuitiva, pois nosso interesse ser\'{a} operar com essas classes. Dessa forma, vamos estipular que o nome da classe seja dado pela sua 
primeira marca\c{c}\~{a}o, por exemplo: em $A=\{x\in\mathbb{N^*}: x=1+26\}$ o n\'{u}mero 1 indica a primeira posi\c{c}\~{a}o ocupada pela letra $A$, por isso a classe da letra $A$ ser\'{a} representada pelo n\'{u}mero $\overline{1}$. A barra \'{e} 
para diferenciar o nome da classe de seu elemento, o n\'{u}mero 1. 

A criptografia RSA usa essa mesma estrat\'{e}gia para iniciar a codifica\c{c}\~{a}o de uma mensagem, por isso a aritm\'{e}tica
modular ser\'{a} essencial para o todo o processo. 
 
Primeiramente, precisamos deixar claro como nomear essas classes, estabelecer o tamanho do ciclo que est\'a sendo adotado 
e o contexto em que desejamos trabalhar para ent\~{a}o podermos definir as opera\c{c}\~{o}es entre esses elementos.
 

\begin{Df}
	Seja $\sim$ uma rela\c{c}\~{a}o e $X$ um conjunto, sendo $x$, $y$ e $z$ elementos de $X$. 
	Uma classe em $X$ \'{e} chamada de \textsl{equival\^{e}ncia} se 
	para todo elemento de $X$ as seguintes propriedades forem satisfeitas:
	\begin{itemize}
		\item Reflexividade: $x\sim x$; 		
		\item Simetria: se $x\sim y$, ent\~{a}o $y\sim x$; 
		\item Transitividade: se $x\sim y$ e $y\sim z$, ent\~{a}o $x\sim z$.
	\end{itemize}
\end{Df}   
	
	
	Dizemos, nesse caso, que a rela\c{c}\~ao $\sim$ \'e uma rela\c{c}\~{a}o de equival\^encia. 
		
	Seja $X$ um conjunto e $\sim$ uma rela\c{c}\~{a}o de equival\^{e}ncia definida em $X$. Denotamos por $\overline{x}$ 
	a classe de equival\^{e}ncia de $x$ e escrevemos, em s\'{i}mbolos, da seguinte forma:
	
	                     $$\overline{x}=\{y\in X: y\sim x\}$$
	
	Como cada classe \'{e} composta por elementos distintos, para garantir a unicidade da soma precisamos que o 
	seguinte princ\'{i}pio seja satisfeito:
	
	\begin{Th}
		Seja $X$ um conjunto e $\sim$ uma rela\c{c}\~{a}o de equival\^{e}ncia definida em $X$, ent\~{a}o:
		$$\textrm{Se } x\in X \textrm{ e } y\in\overline{x} \textrm{ ent\~{a}o } \overline{x}=\overline{y}$$
	\end{Th}
	
	\begin{proof}
		Para mostrar a igualdade entre dois conjuntos devemos mostrar que $\overline{x}\subseteq\overline{y}$
		e $\overline{y}\subseteq\overline{x}$ s\~ao verificadas. Vamos demonstrar o primeiro caso, o outro \'{e} an\'{a}logo.
			
		Tome $z\in\overline{x}$, ent\~{a}o $z\sim x$. Dado que $y\in\overline{x}$
			ent\~{a}o $y\sim x$, da\'{i} pela propriedade sim\'{e}trica temos que $x\sim y$. Logo, j\'{a} que 
			$z\sim x$ e $x\sim y$ ent\~{a}o, pela transitividade, temos que $z\sim y$, isto \'{e}, $z\in\overline{y}$.
			Portanto, $\overline{x}\subseteq\overline{y}$. 
	\end{proof}
	
	O resultado acima mostra que duas classes de equival\^{e}ncia n\~{a}o compartilham elementos, isto \'{e}, as classes de equival\^{e}ncia
	n\~{a}o t\^{e}m elementos em comum, vide exemplos acima. Como consequ\^{e}ncia deste fato temos que o conjunto $X$ \'{e} a 
	uni\~{a}o de todas as classes de equival\^{e}ncia. 
	
	O conjunto das classes de equival\^{e}ncia em $X$ \'{e} chamado \textit{conjunto quociente de $X$ por $\sim$} e 
	seus elementos s\~{a}o formados por subconjuntos de $X$ separados pela rela\c{c}\~{a}o de equival\^{e}ncia.
	
	Nosso interesse ser\'{a} separar em classes de equival\^{e}ncia o conjunto dos n\'{u}meros inteiros, dessa forma $X$ representa
	o conjunto $\mathbb{Z}$, e $x$ um n\'{u}mero inteiro enquanto que
	$\sim$ representa alguma rela\c{c}\~{a}o estabelecida entre os n\'{u}meros inteiros. 
	
	Considere o exemplo em que as classes s\~{a}o compostas aqueles n\'{u}meros que partilham do mesmo resto quando s\~{a}o divididos por 
	5. Neste caso podemos formar cinco classes distintas em $\mathbb{Z}$, a saber:
	\begin{itemize}
		\item Classe do resto zero: $\overline{0}=\{0, 5, 10, 15, 20, \cdots\}$
		\item Classe do resto um: $\overline{1}=\{1, 6, 11, 16, 21, \cdots\}$
		\item Classe do resto dois: $\overline{2}=\{2, 7, 12, 17, 22, \cdots\}$
		\item Classe do resto tr\^{e}s: $\overline{3}=\{3, 8, 13, 18, 23, \cdots\}$
		\item Classe do resto quatro: $\overline{4}=\{4, 9, 14, 19, 24, \cdots\}$
	\end{itemize}

	
	No nosso exemplo $\{\bar{0}, \bar{1}, \bar{2}, \bar{3}, \bar{4}\}$ representa conjunto quociente 
	de $\mathbb{Z}$ pela divis\~{a}o por 5, o qual ser\'{a} denotado por $\mathbb{Z}_{5}$. Em termos gerais, 
	o conjunto quociente de $\mathbb{Z}$ pela divis\~{a}o por $n\neq 0$ \'{e} denotado por:

	$$\mathbb{Z}_{n}=\{\overline{0}, \overline{1}, \overline{2}, \cdots, \overline{n-1}\}$$ 

Pelo teorema de divis\~{a}o (Teorema~\ref{teo.div}) sabemos que a divis\~{a}o de $a$ pode $n$ \'{e} expressa como:
$a=kn+r$, com $0\leq r< k$. Dessa forma, podemos expressar esse fato como $a-r=kn$, para algum $k\in\mathbb{Z}$. Isso 
quer dizer que a diferen\c{c}a $a-r$ \'{e} um m\'{u}ltiplo de $n$. Ser\'{a} conveniente nos referirmos aos elementos 
de uma mesma classe em $\mathbb{Z}_{n}$ dessa maneira olhando para a diferen\c{c}a entre eles, como mostramos a seguir. 
   
Dizemos que dois inteiros $a$ e $b$ s\~{a}o \textit{congruentes m\'{o}dulo $n$} se a diferen\c{c}a $a-b$ \'{e} um 
m\'{u}ltiplo de $n$. Nesse caso, denotamos da seguinte forma:

$$a \equiv b \pmod{n}$$ 

Observe que $12 \equiv 22 \pmod{5}$, pois $12-22=-10$ e $-10$ \'{e} um m\'{u}ltiplo de 5. 

A defini\c{c}\~{a}o acima formaliza a ideia de ``pular de $n$ em $n$'' como \'{e} poss\'{i}vel notar 
pelos exemplos dados. Vejamos mais alguns exemplos de elementos equivalentes segundo um determinado pulo:
\begin{itemize}
	\item $8 \equiv 0 \pmod{4}$, pois $8-0=8$ e 8 \'{e} um m\'{u}ltiplo de 4;
	\item $14 \equiv 24  \pmod{5}$, pois $14-24=-10$ e $-10$ \'{e} um m\'{u}ltiplo de 5;
	\item $25 \equiv 5 \pmod{5}$, pois $25-5=20$ e 20 \'{e} um m\'{u}ltiplo de 5;
\end{itemize}

Observe que a congru\^{e}ncia entre dois n\'{u}meros depende do m\'{o}dulo esculhido, isto \'{e}, do tamanho 
do pulo que a ser dado. Pode-se mostrar que a congu\^{e}ncia m\'{o}dulo $n$ forma uma rela\c{c}\~{a}o de 
equival\^{e}ncia. N\~{a}o daremos essa demonstra\c{c}\~{a}o aqui e o leitor interessado pode encontr\'{a}-la no 
cap\'{i}tulo 4 em \cite{cou:2014}.

Nosso principal objetivo, agora, \'{e} mostrar como podemos operar com essas classes. Veremos que as 
opera\c{c}\~{o}es em $\mathbb{Z}_{n}$ mant\'{e}m as mesmas propriedade satisfeitas em $\mathbb{Z}$.

\begin{Df}
Sejam $\overline{a},\overline{b}\in\mathbb{Z}_{n}$. As opera\c{c}\~{o}es \textit{adi\c{c}\~{a}o}, 
\textit{subtra\c{c}\~{a}o} e \textit{multiplica\c{c}\~{a}o} em $\mathbb{Z}_{n}$ s\~{a}o dadas por:
	\begin{itemize}
			\item \textbf{Adi\c{c}\~{a}o:} $\overline{a}+\overline{b}=\overline{a+b}$;
			\item \textbf{Subtra\c{c}\~{a}o:} $\overline{a}-\overline{b}=\overline{a-b}$;
			\item \textbf{Multiplica\c{c}\~{a}o:} $\overline{a}\times\overline{b}=\overline{a\times b}$;
	\end{itemize}
\end{Df}

Como estamos operando com classes, qualquer elemento da classe pode ser tomado como representando 
a classe a qual ele pertence, dessa forma, precisamos nos certificar de que o resultado dessas opera\c{c}\~{o}es 
independem do representante da classe. Vejamos, por meio do exemplo, a validade desta propriedade para a soma.

Sejam $\overline{4},\overline{3}\in\mathbb{Z}_{5}$. Queremos mostrar que a soma desses elementos independe do 
elemento tomado na classe como sendo seu representante.Tome 4 e 9 como representantes da classe $\overline{4}$ e
tome 3 e 8 como representantes da classe $\overline{3}$. Ent\~{a}o:
				\begin{itemize}
					\item $\overline{4}+\overline{3}=\overline{4+3}=\overline{7}$
					\item $\overline{4}+\overline{3}=\overline{9+8}=\overline{17}$ 
				\end{itemize}
Como $7\in\overline{2}$ e $17\in\overline{2}$, ent\~{a}o $\overline{7}=\overline{17}=\overline{2}$.

Sejam $\overline{a}, \overline{b}$ e $\overline{c}$ elementos de $\mathbb{Z}_{n}$. 
As seguintes propriedades s\~{a}o v\'{a}lidas para a adi\c{c}\~{a}o e multiplica\c{c}\~{a}o:

\[
\begin{array}{rclr}
(\overline{a}+\overline{b})+\overline{c} &=& \overline{a}+(\overline{b}+\overline{c}) & \hfill\textrm{ Associatividade da soma}\\
\overline{a}+\overline{b}									 &=& \overline{b}+\overline{a} 								& \hfill\textrm{ Comutatividade da soma}\\
\overline{a}+\overline{0} 							 &=& \overline{a} 														& \hfill\textrm{ Elemento neutro da soma}\\
\overline{a}+\overline{-a}							 &=& \overline{0} 														& \hfill\textrm{ Elemento oposto }\\
(\overline{a}\times\overline{b})\times\overline{c} &=& \overline{a}\times(\overline{b}\times\overline{c}) & \hfill\textrm{ Associatividade do produto}\\
\overline{a}\times\overline{b}								 &=& \overline{b}\times\overline{a} 								& \hfill\textrm{ Comutatividade do produto}\\
\overline{a}\times\overline{1} 							 &=& \overline{a} 														& \hfill\textrm{ Elemento neutro do produto}\\
\overline{a}\times(\overline{b}+\overline{c})&=& \overline{a}\times\overline{b}+\overline{a}\times\overline{c} 														& \hfill\textrm{ Distributividade}\\
\end{array}
\]

A demonstra\c{c}\~{a}o dessas propriedades seguem imediatamente das propriedades correspondentes em $\mathbb{Z}$.
Vejamos onde a aritm\'{e}tica modular se difere da aritim\'{e}tica em $\mathbb{Z}$. Considere as classes 
$\overline{2}$ e $\overline{6}$ em $\mathbb{Z}_{6}$. Claramente essas classes s\~{a}o diferentes
da classe $\overline{0}$, no entanto vale que:

$$\overline{2}\times\overline{3}=\overline{6}=\overline{0}$$
 
Isso indica que a aritm\'{e}tica modular \'{e} diferente da aritm\'{e}tica em $\mathbb{Z}$. Fatos como esses 
permitem que certas propriedades que n\~{a}o s\~{a}o v\'{a}lidas em $\mathbb{Z}$ passem a valer em $\mathbb{Z}_{n}$, como veremos 
adiante. 

Para completar o estudo das opera\c{c}\~{o}es modulares est\'{a} faltando definir a divis\~{a}o entre os elementos de $\mathbb{Z}_{n}$.
Mas, antes, lembre que em $\mathbb{Z}$ a frase ``dividir $a$ por $b$'', para $b\neq 0$, \'{e} equivalente a dizer
``multiplicar $a$ por $\frac{1}{b}$'', onde $\frac{1}{b}$ \'{e} chamado \textit{inverso} de $b$. 
Em $\mathbb{Z}_{n}$ a divis\~{a}o \'{e} definida nessa formula\c{c}\~{a}o equivalente, como mostramos a seguir. 

\begin{Df}
 Sejam $\overline{a},\overline{\alpha}\in\mathbb{Z}_{n}$. Dizemos que $\overline{\alpha}$ \'{e} o
iverso de $\overline{a}$ se a seguinte equa\c{c}\~{a}o for satisfeita em $\mathbb{Z}_{n}$:
							$$\overline{a}\times\overline{\alpha}=1$$  
\end{Df}


A exist\^{e}ncia de elemento inverso em $\mathbb{Z}_{n}$ ser\'{a} de suma import\^{a}ncia para a criptografia RSA,
pois ser\'{a} justamente essa opera\c{c}\~{a}o que ir\'{a} permitir que uma mensagem seja decodificada uma vez que teremos 
um modo de fazer o percurso inverso. Para que isso seja poss\'{i}vel ser\'{a} conveniente coletar todos os elementos que admitem 
inverso num mesmo conjunto para serem usados na codifica\c{c}\~{a}o de uma mensagem, como veremos mais adiante.
  
\begin{Th}[Teorema de Invers\~ao]\label{inversao}
A classe $\overline{a}$ tem inverso em $\mathbb{Z}_n$ se, e somente se, $a$ e $n$ n\~ao s\~ao primos entre si.
\end{Th}

\begin{proof}
($\Longrightarrow$) Suponha que $\overline{a}$ tenha inverso em $\mathbb{Z}_n$, ent\~{a}o existe um $\overline{\alpha}$ tal que
 $\overline{a} \times \overline{\alpha} =\overline{1}$. Isso \'{e} equivalente a dizer que $a\times\alpha-1$ 
\'{e} divis\'{i}vel por $n$, ou seja, existe $k\in\mathbb{Z}$ tal que: 
								$$a\times\alpha+k\times n=1\eqno(1.2)$$


Pelo Teorema~\ref{alg.eucl.est.} observamos que (1.2) afirma que $mdc(a,n)=1$. 


($\Longleftarrow$) Supondo que $a$ seja um inteiro e que $mdc(a,n)=1$. O Teorema~\ref{alg.eucl.est.}
 garante que existem $\alpha$ e $\beta$ tais que $a\times\alpha+n\times\beta=1$. Mas esta equa\c{c}\~{a}o \'{e}
equivalente a:
$$\overline{a}\times\overline{\alpha}=\overline{1}$$
\end{proof}

\begin{Ex}
Vejamos como encontrar o inverso de $\overline{3}$ em $\mathbb{Z}_{32}$.

Para saber se o inverso existe devemos aplicar o algoritmo euclidiano estendido
para calcular o m\'{a}ximo divisor comum entre eles. Caso seja igual a 1, o algoritmo
indicar\'{a} qual \'{e} o inverso de $\overline{3}$ em $\mathbb{Z}_{32}$. 

\[
\begin{array}{|c|c|c|c|}\hline
\textrm{ Restos } & \textrm{ Quocientes } & x       								& y \\ \hline
				32 	    & \ast     							& 1      									& 0 \\ \hline
				3  			& \ast     							& 0       								& 1 \\ \hline
				2       & 10   					 	  		& x_{1}=1-10\cdot 0 = 1   & y_{1}=0-10\cdot 1=-10 \\ \hline
				1     	& 1    									& x_{2}=0-1\cdot 1=-1     & y_{2}=1-1(-10)=11 \\ \hline
				0    	  & 1    									& \ast         & \ast \\ \hline  
\end{array}
\]

Portanto, $\alpha=-1$ e $\beta=11$ e $mdc(32,3)=(-1)\cdot(32)+(11)\cdot(3)=1$. 

Logo, o inverso existe. Como $3\times 11-32=1$, isso equivale a dizer que: 
$$\overline{3}\times\overline{11}=\overline{1} \textrm{ em }\mathbb{Z}_{32}$$

ou seja, $\overline{11}$ \'{e} o inverso de $\overline{3}$ em $\mathbb{Z}_{32}$.
\hfill$\square$ 
\end{Ex}

Como n\~{a}o s\~{a}o todos os elementos em $\mathbb{Z}_{n}$ que admitem inverso, ser\'{a} conveniente agrup\'{a}-los num 
mesmo conjunto para termos acesso a eles. Denotamos o conjunto dos elementos de $\mathbb{Z}_{n}$ que admitem 
inverso por $\mathcal{U}(n)$ e o descrevemos como:

$$\mathcal{U}(n) = \left\{\overline{a} \in \mathbb{Z}_{n} : mdc(a,n) = 1\right\}$$

\'{E} f\'{a}cil calcular $\mathcal{U}(n)$ quando $p$ \'{e} primo. De fato, como todo inteiro pode ser 
escrito de maneira \'{u}nica como produto de primos, sendo $p$ um fator de $a$ temos que $p$ divide $a$,
isso significa que $a\in\overline{0}$ em $\mathbb{Z}_{p}$. Caso contr\'{a}rio $p$ n\~{a}o divide $a$, nesse caso 
como $p$ \'{e} primo ent\~{a}o $mdc(a, p)=1$, portanto $\overline{a}$ admite inverso em $\mathbb{Z}_{p}$. 
Dessa forma, para $p$ primo todas as classes distintas da 
classe $\overline{0}$ admitem inverso, isto \'{e}:
$$\mathcal{U}(p)=\mathbb{Z}_{p}-{\overline{0}}, \textrm{para } p  \textrm{ primo}$$

Uma propriedade importante de $\mathcal{U}(n)$ \'{e} que ele \'{e} fechado por produto, isto \'{e}, o produto de dois 
elementos de $\mathcal{U}(n)$ est\'{a} em $\mathcal{U}(n)$ e o inverso do produto \'{e} dado pelo produto dos 
inversos, isto \'{e}, se $\overline{\alpha}$ e $\overline{\beta}$
s\~{a}o respectivamente os inversos de  $\overline{a}$ e $\overline{b}$,  ent\~{a}o $\overline{\alpha}\times\overline{\beta}$
\'{e} o inverso de $\overline{a}\times\overline{b}$. 

\'{E} poss\'{i}vel determinar a quantidade de elementos do conjunto $\mathcal{U}(n)$ usando a chamada \textsl{fun\c{c}\~{a}o 
totiente} ou \textsl{fun\c{c}\~{a}o de Euler} $\phi(n)$, a qual denota a ordem de $\mathcal{U}(n)$. Para nosso 
prop\'{o}sito vamos precisar apenas tratar do conjunto $\mathcal{U}(p)$ para $p$ um n\'{u}mero primo e isso nos polpar\'{a} de 
uma s\'{e}rie de resultados t\'{e}cnicos envolvendo teoria de grupos. Para detalhes acerca deste tema sugerimos
o cap\'{i}tulo 8 de \cite{cou:2014}. 

Como vimos acima, $\mathcal{U}(p)$ tem $p-1$ elementos pois a classe $\overline{0}$ n\~{a}o est\'{a} em $\mathcal{U}(n)$, 
da\'{i} para $p$ primo temos que a fun\c{c}\~{a}o totiente resulta em:
$$\phi(p)=(p-1)$$

N\~{a}o \'{e} dif\'{i}cil calcular $\phi(p^{k})$, pois sendo $p$ um n\'{u}mero primo, temos que a quantidade de inteiros 
positivos menores que $p^{k}$ e que n\~{a}o o dividem, isto \'{e}, cujo m\'{a}ximo divisor comum \'{e} 1, \'{e} dado por:

$$\phi(p^{k})=p^{k}-p^{k-1}=p^{k-1}(p-1)$$    

O seguinte teorema, o qual n\~{a}o demonstraremos aqui, mostra como generalizar os resultados acima mencionados.

\begin{Th}\label{totiente}
	Se $m$, $n$ s\~{a}o inteiros positivos tais que $mdc(m,n)=1$, ent\~{a}o $$\phi(mn)=\phi(n)\phi(n)$$
\end{Th}
\begin{proof}
	Confira a se\c{c}\~{a}o 4, cap\'{i}tulo 8 em \cite{cou:2014}.
\end{proof} 
 
Na criptografia RSA usaremos o resultado acima para construir a chave de codifica\c{c}\~{a}o de uma mensagem como mostraremos 
no pr\'{o}ximo cap\'{i}tulo. 

Nesse momento temos a nossa disposi\c{c}\~{a}o todos os resultados que precisamos para construir o algoritmo RSA, mas
vamos usar o chamado \textit{teorema de Fermat} para efetuar simplica\c{c}\~{o}es de n\'{u}meros envolvendo pot\^{e}ncias
muito altas. O teorema de Fermat aparece em duas vers\~{o}es e para o nosso prop\'{o}sito vamos precisar apenas da 
vers\~{a}o chamada \textit{pequeno teorema de Fermat}.

\begin{Th}[Teorema de Fermat]\label{fermat}
	Seja $p$ um n\'{u}mero primo e $a$ um n\'{u}mero inteiro, ent\~{a}o
	$$a^{p}\equiv a \pmod{p}$$
\end{Th}
\begin{proof}
	Confira na se\c{c}\~{a}o 3 do cap\'{i}tulo 5 em \cite{cou:2014}.
\end{proof}

 O teorema afirma que se $p$ \'{e} primo e $a$ um inteiro qualquer, ent\~{a}o $p$ divide a diferen\c{c}a $a^{p}-a$
 em $\mathbb{Z}_{p}$. 
 A outra vers\~{a}o sai como consequ\^{e}ncia do teorema anterior como mostramos a seguir.
 
\begin{Th}[Pequeno Teorema de Fermat]\label{pequeno.fermat}
Seja $p$ um n\'{u}mero primo e $a$ um n\'{u}mero inteiro que n\~ao \'{e} divis\'ivel por $p$. Ent\~ao:
$$a^{p-1}\equiv 1 \pmod{p}$$
\end{Th}
\begin{proof}
	Se $p$ n\~{a}o divide $a$, ent\~{a}o pelo Teorema~\ref{inversao} sabemos que $a$ admite inverso em $\mathcal{U}(p)$, da\'{i}
	existe $\overline{\alpha}\in\mathcal{U}(p)$ tal que $\overline{a}\cdot\overline{\alpha}=\overline{1}$, isto \'{e},
	$a\cdot\alpha\equiv 1 \pmod{p}$. Multiplicando por $\alpha$ ambos os membros de 
	$a^p \equiv a \pmod{p}$ dada no Teorema~\ref{fermat} obtemos $\alpha\cdot a^p \equiv \alpha\cdot a \pmod{p}$, o que 
	equivale a:
	$$\alpha\cdot a\cdot a^{p-1} \equiv \alpha\cdot a \pmod{p}\hfill \eqno (1.3)$$
	Substituindo $a\cdot\alpha\equiv 1 \pmod{p}$ em (1.3) obtemos que $a^{p-1} \equiv 1 \pmod{p}$.
\end{proof}

O Teorema de Fermat \'e usado para simplificar os c\'{a}lculos na obten\c{c}\~{a}o de congru\^encias e isso ser\'{a}
muito \'{u}til porque teremos que trabalhar com n\'{u}meros muito grandes para poder garantir a seguran\c{c}a na criptografia RSA.

Vejamos como aplicar o teorema para simplificar os c\'{a}lculos na pr\'{a}tica.

Para calcular $2^{5432675}$ m\'{o}dulo 13, usando o Teorema~\ref{pequeno.fermat} basta calcular o resto da 
divis\~{a}o de $5432675$ por $12=13-1$, que resulta em $11$. Assim, 
temos que $2^{5432675}\equiv 2^{11}\equiv 7 \pmod{13}$. 



Outro resultado usado para decodificar uma mensagem na criptografia RSA \'{e} o chamado \textit{Teorema Chin\^{e}s do resto}. Esse teorema
\'{e} \'{u}til para resolver sistemas de congru\^{e}ncias, isto \'{e}, sistemas envolvendo situa\c{c}\~{o}es com ciclos, por exemplo: para saber quando tr\^{e}s sat\'{e}lites que giram em torno da Terra com ciclos diferentes estar\~{a}o alinhados usamos o teorema chin\^es do resto. 

Na pr\'{a}tica, o teorema chin\^{e}s do resto \'{e} um procedimento usado para encontrar uma classe de equival\^{e}ncia 
adequada para ser solu\c{c}\~{a}o do sistema, mas em uma outra base. Uma equa\c{c}\~{a}o
envolvendo congru\^{e}ncias \'{e} dada pela express\~{a}o:
$$ax\equiv b  \pmod{n}\hfill\eqno(1.4)$$
Queremos determinar o valor de $x$ de modo a tornar verdadeira a equa\c{c}\~{a}o em $\mathbb{Z}_{n}$. Primeiramente temos que considerar duas possibilidades: (i) $\overline{a}$ tem inverso em $\mathbb{Z}_{n}$; (ii) $\overline{a}$ n\~{a}o tem inverso em $\mathbb{Z}_{n}$.
\begin{description}
	\item [(i)] Se $\overline{a}$ tem inverso, ent\~{a}o existe $\overline{\alpha}\in\mathbb{Z}_{n}$ tal que 
				$\overline{a}\cdot\overline{\alpha}\equiv\overline{1}$. Da\'{i}, se multiplicarmos a equa\c{c}\~{a}o
				(1.4) por $\overline{\alpha}$ resulta que $x\equiv \alpha\cdot b \pmod{n}$  \'{e} a solu\c{c}\~{a}o 
				da equa\c{c}\~{a}o.
	\item [(ii)] Se $\overline{a}$ n\~{a}o tem inverso em $\mathbb{Z}_{n}$, ent\~{a}o $mdc(a, n)=d\neq 1$. Dizer que a equa\c{c}\~{a}o (1.4) tem
	      solu\c{c}\~{a}o significa que existem inteiros $x$ e $y$ tais que 
				$$ax-ny=b\hfill\eqno(1.5)$$ 
				Por um lado, como $d$ divide $a$ e $d$ divide $n$, ent\~{a}o $d$ divide $b$. Da\'{i}, existem inteiros $a'$, $b'$ e $c'$ tais que 
				$a=da'$, $b=db'$ e $n=dn'$. Substituindo essas identidades em (1.5) segue que
				$da'x-dn'y=db'$.
				Dividindo toda a express\~{a}o por $d$ temos que
				$a'x-n'y=b'$ e isso significa que 
				$$a'x\equiv b'\pmod{n'}\hfill\eqno(1.6)$$ 
				Agora, 
				como $mdc(a, n)=d$ ent\~{a}o pelo Teorema~\ref{alg.eucl.est.} temos que  existem inteiros $\alpha$ e $\beta$
				tais que $a\alpha+n\beta=d$, da\'{i} substituindo as
				identidades obtidas acima temos que $da'\alpha+dn'\beta=d$, da\'{i} dividindo toda a express\~{a}o por 
				$d$ segue que $a'\alpha+n'\beta=1$, isto \'{e}
				$mdc(a', n')=1$, logo $\overline{a'}$ admite inverso em $\mathbb{Z}_{n'}$, o qual chamamos de $\overline{\gamma}$.
				Portanto, multiplicando a express\~{a}o (1.6) por $\overline{\gamma}$ segue que $x\equiv\gamma\cdot b'\pmod{n'}$
				\'{e} a solu\c{c}\~{a}o da equa\c{c}\~{a}o.						
\end{description}

Para decodificar uma mensagem criptografada pelo RSA ser\'{a} necess\'{a}rio resolver sistemas envolvendo apenas duas 
equa\c{c}\~{o}es de congru\^{e}ncias por isso optamos por n\~{a}o trabalhar com o caso geral de sistemas envolvendo 
mais de duas equa\c{c}\~{o}es nesta monografia.

Considere o seguinte sistema:
\[
\begin{array}{ccc}
	x & \equiv & a \pmod{m}\\
	x & \equiv & b \pmod{n}\\
\end{array}
\]

O sistema pode ser resolvido seguindo os seguintes passos:
\begin{enumerate}
	\item A primeira equa\c{c}\~{a}o pode ser reescrita na forma $x=a+my$, para algum inteiro $y$;
	\item Substituindo a express\~{a}o obtida no item anterior na segunda equa\c{c}\~{a}o temos: $a+my\equiv b \pmod{n}$;
	\item A equa\c{c}\~{a}o anterior pode ser reescrita na forma $my\equiv (b-a) \pmod{n}$;
	\item Resolva a \'{u}ltima equa\c{c}\~{a}o usando o procedimento descrito anteriormente e encontre o valor de $y$.
	\item Para encontrar a solu\c{c}\~{a}o basta substituir o valor de $y$ na equa\c{c}\~{a}o dada no passo 1. 
\end{enumerate}

Considere, como exemplo, o problema de calcular o menor inteiro $x$ cujo resto \'{e} $1$ na divis\~ao por $3$, 
e cujo resto \'{e} $2$ na divis\~ao por $5$. Esse problema pode ser descrito pelo seguinte sistema de equa\c{c}\~oes:

\[
\begin{array}{ccc}
x & = & 1\pmod{3} \\
x & = & 2 \pmod{5}\\
\end{array}
\]

A primeira equa\c{c}\~{a}o pode ser escrita como $x=1+3y$ para algum inteiro $y$. Substitua o valor de $x$ na segunda 
equa\c{c}\~{a}o e obtenha $1+3y=2\pmod{5}$, isto \'{e} $3y=1\pmod{5}$. 

Como $mdc(3,5)=1$ ent\~{a}o multiplicando toda a express\~{a}o pelo inverso de $\overline{3}$ em $\mathbb{Z}_{5}$, a saber, 
por $\overline{2}$, obtemos que $y=2\pmod{5}$. Isso significa que $y=2+5k$ para $k\in\mathbb{Z}$.  
Da\'{i}, substituindo em $x=1+3y$ obtemos que $x=1+3(2+5k)$, isto \'{e}, $x=7+15k$, ou seja, $x\equiv 7\pmod{15}$.  

O procedimento exemplicado acima pode ser sintetizado pelo seguinte teorema:

\begin{Th}[Teorema Chin\^es do Resto]\label{chines}
Sejam $n_1, n_2, \cdots n_k$ inteiros positivos dois a dois primos entre si. O sistema
\[
\begin{array}{ccc}
 x & \equiv & a_1 \pmod n_1\\ 
 x & \equiv & a_2 \pmod n_2 \\
   & \vdots &   \\
x & \equiv & a_k \pmod n_k \\	
\end{array}
\]
sempre tem uma solu\c{c}\~ao em $\mathbb{Z}_{n_1\cdots n_k}$.
\end{Th}
\begin{proof}
  Veja a se\c{c}\~{a}o 5 do cap\'{i}tulo 7 em \cite{cou:2014}.  
\end{proof}

Para encerrarmos este cap\'itulo vejamos como podemos combinar o teorema de Fermat (Teorema~\ref{fermat}) 
e o teorema chin\^es do resto (Teorema~\ref{chines}) a fim de simplificar o c\'{a}lculo de pot\^{e}ncias 
m\'{o}dulo $n$. Mostraremos esse procedimento por meio de um exemplo.


O primeiro passo ser\'{a} fatorar o n\'{u}mero que aparece no m\'{o}dulo. Vamos supor que 
todos os fatores primos que ocorrem na fatora\c{c}\~{a}o tem multiplicidade igual a 1, pois esse ser\'{a} o 
caso que vamos utilizar neste trabalho. Claramente os fatores primos s\~{a}o dois a dois primos entre si,
da\'{i} o Teorema~\ref{chines} afirma que existe uma \'{u}nica solu\c{c}\~{a}o para um sistema 
cujos os m\'{o}dulos s\~{a}o dados por tais fatores. Para cada fator primo obtido na fatora\c{c}\~{a}o iremos encontrar a 
classe a qual a pot\^{e}ncia dada no problema pertence usando o Teorema~\ref{fermat}, e com isso podemos construir um 
sistema cuja solu\c{c}\~{a}o resultar\'{a} na simplifica\c{c}\~{a}o da pot\^{e}ncia dada. 

Vejamos como calcular $2^{6754} \pmod{1155}$. 					

Fatorando $1155$ temos que $1155= 3 \times 5 \times 7 \times 11$. Agora, vamos aplicar o Teorema~\ref{pequeno.fermat} 
a cada um dos primos, obtendo as seguintes equival\^{e}ncias:
\[
\begin{array}{ccl}
 2^2    & \equiv & 1 \pmod{3}\\
 2^4    & \equiv & 1 \pmod{5}\\ 
 2^6    & \equiv & 1 \pmod{7}\\  
 2^{10} & \equiv & 1 \pmod{11}\\
\end{array}
\]

Agora, dividindo $6754$ por $p-1$, para $p\in\{3, 5, 7, 11\}$, temos:
\[
\begin{array}{ccl}
  6754 & = & 2 \times 3377 + 0 \\  
	6754 & = & 4 \times 1688 + 2 \\
  6754 & = & 6 \times 1125 + 4 \\
  6754 & = & 10 \times 675 + 4 \\ 
\end{array}
\]
Em seguida substitu\'imos as identidades acima nas congru\^encias e as reduzimos
\[
\begin{array}{cccccc}
2^{6754} & = & 2^{2\times 3377}   & = & (2^{3377})^{2} & \equiv 1 \pmod{3} \\  
2^{6754} & = & 2^{4\times 1688+2} & = & (2^{1688})^{4} & \equiv 4 \pmod{5}\\  
2^{6754} & = & 2^{6\times 1125+4} & = & (2^{1125})^{6} & \equiv 2 \pmod{7}\\ 
2^{6754} & = & 2^{10\times 675+4} & = & (2^{675})^{10} & \equiv 5 \pmod{11}\\  
\end{array}
\]
Logo, a tarefa, agora, consiste em resolver o seguinte sistema:
\[
\begin{array}{ccc}
  x & \equiv & 1 \pmod{3}\\
  x & \equiv & 4 \pmod{5}\\
  x & \equiv & 2 \pmod{7}\\
  x & \equiv & 5 \pmod{11}\\  
\end{array}
\]

Agora, basta resolver o sistema usando o algoritmo chin\^{e}s. 
\begin{enumerate}
\item A primeira congru\^{e}ncia equivale a dizer que $x = 3y + 1$; 
\item Substituindo $x$ na segunda congru\^encia temos que $3y + 1 \equiv 4 \pmod{5}$. Isso equivale a dizer que $y \equiv 1 \pmod{5}$, 
isto \'{e}, $y=5k+1$, para algum $k\in\mathbb{Z}$; 
\item Substituindo o valor de $y$ em $x=3y+1$ temos $x=4+15z$.
\item Substitua o novo valor de $x$ na terceira congru\^{e}ncia e obtenha $4+15z\equiv 2\pmod{7}$. Isso equivale a
      $15z\equiv -2\pmod{7}$, isto \'{e}, $z\equiv 5\pmod{7}$ e da\'{i} $z=7t+5$, para $t\in\mathbb{Z}$.
\item Agora, substituindo o valor de $z$ em $x=4+15z$ obtemos que $x=4+15(7t+5)$, isto \'{e}, $x=105t+79$.
\item Substituindo o valor de $x$ que acabamos de obter na \'{u}ltima congru\^{e}ncia temos 
      $105t+79\equiv 5 \pmod{11}$, isto \'{e},  $t\equiv 6 \pmod{11}$, o que resulta em 
				$x = 709+1155u$ para $u\in\mathbb{Z}$. Conclu\'imos com isso que $2^{6754} \equiv 709 \pmod{1155}$.
\end{enumerate}

Agora estamos em condi\c{c}\~{o}es de apresentar o funcionamento do algor\'{i}tmo RSA, o que faremos no pr\'{o}ximo cap\'{i}tulo. 